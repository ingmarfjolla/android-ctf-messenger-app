
// partially sourced from : https://github.com/rsenet/FriList/blob/main/02_SecurityBypass/DebugMode_Emulator/android-emulator-detection-bypass.js#L32
Java.perform(function()
{
    console.log("--> Anti Emulator Detection Bypass - Script Loaded")

    bypassABI()
    bypass_build_properties()
    fake_sensors()
    bypass_has_file()
});

function bypassABI()
{
    var Build = Java.use("android.os.Build");
    Build.SUPPORTED_ABIS.value = ["armeabi-v7a", "armeabi"];

}


function replaceFinaleField(object, fieldName, value)
{
    var field =  object.class.getDeclaredField(fieldName)
    field.setAccessible(true)
    field.set(null, value)
}

function bypass_build_properties()
{
        console.log("Build Properties - Bypass Loaded")
        // Class containing const that we want to modify
        const Build = Java.use("android.os.Build")

        // reflection class for changing const
        const Field = Java.use('java.lang.reflect.Field')
        const Class = Java.use('java.lang.Class')

        // Replacing Build static fields
        replaceFinaleField(Build, "FINGERPRINT", "abcd/C1505:4.1.1/11.3.A.2.13:user/release-keys")
        replaceFinaleField(Build, "MODEL", "C1505")
        replaceFinaleField(Build, "MANUFACTURER", "Sony")
        replaceFinaleField(Build, "BRAND", "Xperia")
        replaceFinaleField(Build, "BOARD", "7x27")
        replaceFinaleField(Build, "ID", "11.3.A.2.13")
        replaceFinaleField(Build, "SERIAL", "abcdef123")
        replaceFinaleField(Build, "TAGS", "release-keys")
        replaceFinaleField(Build, "USER", "administrator")
}

function fake_sensors()
{
    try {
            var SensorManager = Java.use("android.hardware.SensorManager");
            var ArrayList = Java.use("java.util.ArrayList");
            var Sensor = Java.use("android.hardware.Sensor");

            SensorManager.getSensorList.overload('int').implementation = function (sensorType) {
                console.log("Hooked SensorManager.getSensorList called with type: " + sensorType);

                // Retrieve the original sensor list.
                var originalList = this.getSensorList(sensorType);
                console.log("Original sensor count: " + originalList.size());

                // Create a new list for our custom (fake) sensor(s).
                var fakeList = ArrayList.$new();

                if (originalList.size() > 0) {
                    // Use the first sensor as a base to clone and modify.
                    var realSensor = originalList.get(0);
                    try {
                        // Change the sensor's name.
                        var mNameField = Sensor.class.getDeclaredField("mName");
                        mNameField.setAccessible(true);
                        mNameField.set(realSensor, "Gyroscope");

                        // Change the sensor's vendor.
                        var mVendorField = Sensor.class.getDeclaredField("mVendor");
                        mVendorField.setAccessible(true);
                        mVendorField.set(realSensor, "Samsung");

                        //console.log("Modified sensor: name = " + realSensor.getName() +
                                    //", vendor = " + realSensor.getVendor());
                    } catch (innerErr) {
                        console.log("Error modifying sensor fields: " + innerErr);
                    }
                    // Add the modified sensor to our custom list.
                    fakeList.add(realSensor);
                } else {
                    // If no sensor was returned originally, you could attempt a reflection-based creation,
                    // but that's considerably more complex.
                    console.log("No original sensors found. Returning an empty list.");
                }
                return fakeList;
            };
        } catch (e) {
            console.log("Error hooking SensorManager.getSensorList: " + e);
        }
}

function bypass_has_file()
{
    console.log("Emulator related files check - Bypass Loaded")
    const File = Java.use("java.io.File")
    const KnownFiles= [
        "ueventd.android_x86.rc",
        "x86.prop",
        "ueventd.ttVM_x86.rc",
         "init.ttVM_x86.rc",
        "fstab.ttVM_x86",
        "fstab.vbox86",
        "init.vbox86.rc",
        "ueventd.vbox86.rc",
        "/dev/socket/qemud",
        "/dev/qemu_pipe",
        "/system/lib/libc_malloc_debug_qemu.so",
        "/sys/qemu_trace",
        "/system/bin/qemu-props",
        "/dev/socket/genyd",
        "/dev/socket/baseband_genyd",
        "/proc/tty/drivers",
        "/proc/cpuinfo"
    ]

    File.exists.implementation = function ()
    {
        var x = this.getAbsolutePath();
        for(var i=0; i<KnownFiles.length; i++)
        {
            if(KnownFiles[i] == x)
            {
                console.log("App was looking for "+x+" emulator file - bypass done!")
                return false;
            }
        }

        return this.exists();
    };
}

if (Module.findExportByName("libc.so", "open") !== null) {
    Interceptor.attach(Module.findExportByName("libc.so", "open"), {
        onEnter: function (args) {
            var path = Memory.readCString(args[0]);
            console.log("open() called with: " + path);
            // Optionally, check if the file path is one you want to block:
            if(path.indexOf("/proc/self/task/") !== -1){ this.block = true; }
            //if(path.indexOf("/proc/cpuinfo") !== -1){ this.block = true; }
            //this.block = true; // Block all open calls, for demonstration.
        },
        onLeave: function (retval) {
            if (this.block) {
                console.log("Blocking file access. Returning error (-1).");
                retval.replace(-1);
            }
        }
    });
}